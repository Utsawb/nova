#version 430 core

// Work group size
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Input data
layout(std430, binding = 0) readonly buffer EventParticles {
    vec4 evtParticles[];
};

// Output data
layout(std430, binding = 1) writeonly buffer OutputData {
    vec3 outputData[]; // x, y, weight
};

// Atomic counters for output indexing and reductions
layout(std430, binding = 2) buffer Counters {
    uint outputCount;
    uint rollingXBits;  // Float stored as uint bits for atomic operations
    uint rollingYBits;  // Float stored as uint bits for atomic operations
};

// Uniforms
uniform int eventBound_L;
uniform int eventBound_R;
uniform vec4 spaceWindow; // x = top, y = right, z = bottom, w = left
uniform bool isPositiveOnly;
uniform bool useMorlet;
uniform float morletFreq; // f
uniform float morletCenterT; // center_t
uniform float morletH;
uniform float baseContribution;
uniform float timeBound_L;
uniform float timeBound_R;

// Helper function to check if value is within bounds
bool within_inc(float val, float left, float right) {
    return left <= val && val <= right;
}

// Base contribution function
float getBaseWeight(float polarity) {
    float polarityVal = (polarity == 0.0) ? -1.0 : 1.0;
    return baseContribution * polarityVal;
}

// Morlet contribution function
float getMorletWeight(float t, float polarity) {
    float polarityVal = (polarity == 0.0) ? -1.0 : 1.0;
    
    // Calculate Morlet wavelet
    float t_diff = t - morletCenterT;
    float PI = 3.14159265359;
    
    // exp(2i*pi*f*(t-center_t))
    float phase = 2.0 * PI * morletFreq * t_diff;
    vec2 complex_exp = vec2(cos(phase), sin(phase));
    
    // exp(-4*ln(2)*(t-center_t)^2 / h^2)
    float gaussian = exp(-4.0 * 0.693147 * (t_diff * t_diff) / (morletH * morletH));
    
    // Real part of complex result
    float unweighted = complex_exp.x * gaussian * polarityVal;
    
    if (unweighted < 0.0) {
        return unweighted * 4.0 * baseContribution;
    } else {
        return unweighted * baseContribution;
    }
}

// Shared memory for local reductions
shared float sharedX[256];
shared float sharedY[256];

void main() {
    uint localID = gl_LocalInvocationID.x;
    uint globalID = gl_GlobalInvocationID.x;
    int eventIndex = eventBound_L + int(globalID);
    
    float localX = 0.0;
    float localY = 0.0;
    
    // Bounds check
    if (eventIndex <= eventBound_R) {
        // Read event data
        vec4 evt = evtParticles[eventIndex];
        float x = evt.x;
        float y = evt.y;
        float t = evt.z;
        float polarity = evt.w;
        
        // Check polarity filter
        bool validPolarity = !isPositiveOnly || polarity == 1.0;
        
        // Check spatial bounds
        bool validSpatial = within_inc(x, spaceWindow.w, spaceWindow.y) && 
                           within_inc(y, spaceWindow.x, spaceWindow.z);
        
        if (validPolarity && validSpatial) {
            // Calculate weight based on contribution function
            float weight;
            if (useMorlet) {
                weight = getMorletWeight(t, polarity);
            } else {
                weight = getBaseWeight(polarity);
            }
            
            // Atomically increment output count and get index
            uint outputIndex = atomicAdd(outputCount, 1u);
            
            // Write output
            outputData[outputIndex] = vec3(x, y, weight);
            
            localX = x;
            localY = y;
        }
    }
    
    // Store in shared memory
    sharedX[localID] = localX;
    sharedY[localID] = localY;
    
    barrier();
    
    // Reduction in shared memory
    for (uint stride = 128u; stride > 0u; stride >>= 1u) {
        if (localID < stride) {
            sharedX[localID] += sharedX[localID + stride];
            sharedY[localID] += sharedY[localID + stride];
        }
        barrier();
    }
    
    // First thread writes to global memory using atomic operations
    // Since GLSL doesn't have atomicAdd for float, we use atomicCompSwap
    if (localID == 0u) {
        // For rollingX - atomic float addition using compare-and-swap
        uint oldIntX, newIntX;
        float oldX, newX;
        do {
            oldIntX = rollingXBits;
            oldX = uintBitsToFloat(oldIntX);
            newX = oldX + sharedX[0];
            newIntX = floatBitsToUint(newX);
        } while (atomicCompSwap(rollingXBits, oldIntX, newIntX) != oldIntX);
        
        // For rollingY - atomic float addition using compare-and-swap
        uint oldIntY, newIntY;
        float oldY, newY;
        do {
            oldIntY = rollingYBits;
            oldY = uintBitsToFloat(oldIntY);
            newY = oldY + sharedY[0];
            newIntY = floatBitsToUint(newY);
        } while (atomicCompSwap(rollingYBits, oldIntY, newIntY) != oldIntY);
    }
}
